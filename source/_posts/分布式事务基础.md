---
title: 分布式事务基础
date: 2022-10-05 13:44:19
tags: 
  - Java
  - 分布式
  - 事务
category:
  - 分布式
---

# 事务

## 概念

指的就是一个操作单元，在这个操作单元中的所有操作最终要保持一致的行为，要么所有操作都成功，要么所有的操作都被撤销。

通俗一点？举个生活中的例子：你去小卖铺买东西，“一手交钱，一手交货”就是一个事务的例子，交钱和交货必 须全部成功，事务才算成功，任一个活动失败，事务将撤销所有已成功的活动。

事务可以看做是一次大的操作，它由不同的小操作组成，这些操作要么全部成功，要么全部失败。

## 事务的四个特性（ACID）

![事务特性](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20180614161151856116.2ac01fe6.png)

**原子性**（Atomicity）：操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。``要么执行，要么不执行``

**一致性**（Consistency）：事务的执行使数据从一个状态转换为另一个状态，数据库的完整性约束没有被破坏。``能量守恒，总量不变``

> 拿转账来说，假设用户A和用户B两者的钱加起来一共是2000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是2000，这就是事务的一致性。

**隔离性**（Isolation）：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。``信息彼此独立，互不干扰``

> 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

**持久性**（Durability）：当事务正确完成后，它对于数据的改变是永久性的。``不会轻易丢失``

> 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

# 分布式事务

随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，下图描述了单体应用向微服务的演变：分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操 作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分 事务、创建订单减库存事务，银行转账事务等都是分布式事务。

![img](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/9c9a739e307f0402b809d9cd73ca615e.6eb1d80d.png)

典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的 同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务。

## 分布式事务产生场景

1. 跨JVM进程产生分布式事务

   典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的 同时订单微服务请求库存微服务减库存。

   ![](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20221005144930.png)

2. 跨数据库实例

   典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的 同时订单微服务请求库存微服务减库存。

   ![](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20221005145014.png)

   我们了解到了分布式事务的基础概念。与本地事务不同的是，分布式系统之所以叫分布式，是因 为提供服务的各个节点分布在不同机器上，相互之间通过网络交互。不能因为有一点网络问题就导致整个系统无法 提供服务，网络因素成为了分布式事务的考量标准之一。因此，分布式事务需要更进一步的理论支持，接下来，我们先来学习一下分布式事务的CAP理论。

# CAP原则

CAP原则又叫CAP定理，同时又被称作布鲁尔定理（Brewer's theorem），指的是在一个分布式系统中，**不可能同时满足以下三点**。

![img](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/v2-135c492dbc2225ca86af34b837e446fa_720w.2a34b8c0.jpg)

- 一致性（Consistency）``副本最新``：指强一致性，在写操作完成后开始的任何读操作都必须返回该值，或者后续写操作的结果。

  > 在一致性系统中，一旦客户端将值写入任何一台服务器并获得响应，那么之后client从其他任何服务器读取的都是刚写入的数据
  >
  > 一致性保证了不管向哪台服务器写入数据，其他的服务器能实时同步数据

- 可用性（Availability）``高可用``：可用性是指，每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据）

- 分区容忍性（Partition tolerance）``能容忍网络分区``：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务

  > 服务器A和B发送给对方的任何消息都是可以放弃的，也就是说A和B可能因为各种意外情况，导致无法成功进行同步，分布式系统要能容忍这种情况。除非整个网络环境都发生了故障。

# 分布式事务协议

> **背景**
>
> 在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。

## 二阶段提交`2PC`

二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理。

### 阶段

- 准备阶段
- 提交阶段

### 参与角色

- 协调者：事务的发起者
- 参与者：事务的执行者

### 第一阶段

1. 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复
2. 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）
3. 如参与者执行成功，给协调者反馈**同意**，否则反馈**中止**

![1596360577153](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1596360577153.3453f839.png)

### 第二阶段

当协调者节点从所有参与者节点获得的相应消息都为**同意**时：

1. 协调者节点向所有参与者节点发出**正式提交**(`commit`)的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。

3. 参与者节点向协调者节点发送**ack完成**消息。
4. 协调者节点收到所有参与者节点反馈的**ack完成**消息后，完成事务。

![1596376239082](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1596376239082.8842458a.png)

如果任一参与者节点在第一阶段返回的响应消息为**中止**，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：

1. 协调者节点向所有参与者节点发出**回滚操作**(`rollback`)的请求。
2. 参与者节点利用阶段1写入的undo信息执行回滚，并释放在整个事务期间内占用的资源。

3. 参与者节点向协调者节点发送**ack回滚完成**消息。
4. 协调者节点受到所有参与者节点反馈的**ack回滚完成**消息后，取消事务。

不管最后结果如何，第二阶段都会结束当前事务。

![1596377554340](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1596377554340.ccaebf14.png)

![1596376604142](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1596376604142.7f3e53e1.png)

二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：

 	1. **性能问题**：执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
 	1. **可靠性问题**：参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。
 	1. **可靠性问题**：参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。

> **优点**
>
> 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）

> **缺点**
>
> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。

# 分布式事务解决方案

- TCC
- 全局消息
- 基于可靠消息服务的分布式事务
- 最大努力通知

## 事务补偿（TCC）

TCC方案是一种应用层面侵入业务的两阶段提交。是目前最火的一种柔性事务方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作

1. 第一阶段

​	Try（尝试）：主要是对业务系统做检测及资源预留 **(加锁，锁住资源)**

2. 第二阶段

​	本阶段根据第一阶段的结果，决定是执行confirm还是cancel

​	Confirm（确认）：执行真正的业务``执行业务，释放锁``

​	Cancle（取消）：是预留资源的取消``出问题，释放锁``

![img](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1010726-20191031060901955-1099206419.730de9e5.png)

## 案例

为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。

假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。

1. Try阶段

​	TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：

- 完成所有业务检查( 一致性 ) 。
- 预留必须业务资源( 准隔离性 ) 。
- Try 尝试执行业务。

![img](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/a45bc145f97d4f11a168968cac37dcbb.f0507a86.jpeg) 

2. Confirm / Cancel 阶段

​	根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。

​	Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。

​	**Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作**

![img](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/7297c173bc7845c2bed213ba62073422.e510273b.jpeg)

​	这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。

​	Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。

​	**Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段**

![img](https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/dd580f077bd64db4bf305b3b1657a7df.f3a1e2e2.jpeg)

Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。

## 最终一致性保证

- TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。
- Try阶段执行成功并开始执行 `Confirm`阶段时，默认 `Confirm`阶段是不会出错的。也就是说只要`Try`成功，`Confirm`一定成功``TCC设计之初的定义`` 。
- Confirm与Cancel如果失败，由TCC框架进行==重试==补偿
- 存在极低概率在CC环节彻底失败，则需要定时任务或人工介入

## 方案总结

TCC 事务机制相对于传统事务机制（X/Open XA），TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点：

- 性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。
- 数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。
- 可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。

**缺点：** TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。
