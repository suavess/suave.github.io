<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java中switch关键字对String类型的支持</title>
      <link href="/2022/06/16/Java%E4%B8%ADswitch%E5%85%B3%E9%94%AE%E5%AD%97%E5%AF%B9String%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%94%AF%E6%8C%81/"/>
      <url>/2022/06/16/Java%E4%B8%ADswitch%E5%85%B3%E9%94%AE%E5%AD%97%E5%AF%B9String%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%94%AF%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<p>在java7以后，switch的参数可以是String类型了，到目前为止switch支持这样几种数据类型：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>String</code> 。接下来我们就看一下，switch到底是如何实现的。</p><blockquote><p>ps: 本文使用的反编译工具为jadx</p></blockquote><h3 id="switch对整型的支持"><a href="#switch对整型的支持" class="headerlink" title="switch对整型的支持"></a>switch对整型的支持</h3><p>一段很简单的通过整型进行switch的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过反编译后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="comment">/* loaded from: Test.class */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，经过反编译后的代码基本没有变化，<strong>因此switch对int的判断是直接比较整数的值</strong>。</p><h3 id="switch对字符类型的支持"><a href="#switch对字符类型的支持" class="headerlink" title="switch对字符类型的支持"></a>switch对字符类型的支持</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过反编译之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="comment">/* loaded from: Test.class */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="number">98</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">97</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">98</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的代码作比较我们发现：对char类型进行比较的时候，实际上比较的是ascii码，编译器会把char型变量转换成对应的int型变量</p><h3 id="switch对字符串支持的实现"><a href="#switch对字符串支持的实现" class="headerlink" title="switch对字符串支持的实现"></a>switch对字符串支持的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过反编译之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="comment">/* loaded from: Test.class */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">65535</span>;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="string">&quot;world&quot;</span>.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;world&quot;</span>.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">                    c = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;world&quot;</span>.equals(<span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">                    c = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来字符串的switch是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的。<strong>记住，switch中只能使用整型</strong>，比如<code>byte</code>。<code>short</code>，<code>char</code>(ackii码是整型)以及<code>int</code>。还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。通过这个很容易记住<code>hashCode</code>返回的是<code>int</code>这个事实。仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个<code>equals</code>方法，如果你比较的是字符串字面量的话会非常快，比如”abc” ==”abc”。如果你把<code>hashCode()</code>方法的调用也考虑进来了，那么还会再多一次的调用开销，因为字符串一旦创建了，它就会把哈希值缓存起来。因此如果这个<code>switch</code>语句是用在一个循环里的，比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里<code>hashCode()</code>方法的调用开销其实不会很大。</p><p>总结一下我们可以发现，<strong>其实switch只支持一种数据类型，那就是整型，其他数据类型都是转换成整型之后再使用switch的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编译器对&#39;+&#39;的重载</title>
      <link href="/2022/06/16/Java%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9&#39;+&#39;%E7%9A%84%E9%87%8D%E8%BD%BD/"/>
      <url>/2022/06/16/Java%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9&#39;+&#39;%E7%9A%84%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>Java中对字符串进行拼接一般有两种方式，通过Stirng.concat()方法进行拼接，或者直接使用<code>+</code>号拼接，一般来说，我们都会使用第二种方式。</p><p>有人把Java中使用+拼接字符串的功能理解为运算符重载。其实并不是，Java是不支持运算符重载的。这其实只是Java提供的一个语法糖。</p><blockquote><p>运算符重载：在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p></blockquote><blockquote><p>语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</p></blockquote><p>这样的一段代码，让我们看看反编译后的结果</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220616102447895.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220616102447895.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220616102447895"></p><p>使用IDEA直接查看编译后的class文件</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220616102539916.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220616102539916.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220616102539916"></p><p>通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。</p><p>那么也就是说，Java中的+对字符串的拼接，其实现原理是使用StringBuilder.append。</p><p>但是，String的使用+字符串拼接也不全都是基于StringBuilder.append，还有种特殊情况，那就是如果是两个固定的字面量拼接，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ab = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure><p>反编译后</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220616102923574.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220616102923574.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220616102923574"></p><p>这主要是因为两个字符串都是编译期常量，编译期可知，因此编译器会进行常量折叠，直接变成 String s = “ab”。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁相关（二）</title>
      <link href="/2022/02/28/MySQL%E9%94%81%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/02/28/MySQL%E9%94%81%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Innodb行锁"><a href="#Innodb行锁" class="headerlink" title="Innodb行锁"></a>Innodb行锁</h2><div class="story post-story"><blockquote><p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p></blockquote><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h4><p>事务是由一组SQL语句组成的逻辑处理单元。</p><p>事务具有以下4个特性，简称为事务ACID属性。</p><table><thead><tr><th>ACID属性</th><th>含义</th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td></tr><tr><td>一致性（Consistent）</td><td>在事务开始和完成时，数据都必须保持一致状态。</td></tr><tr><td>隔离性（Isolation）</td><td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td></tr><tr><td>持久性（Durable）</td><td>事务完成之后，对于数据的修改是永久的。</td></tr></tbody></table><h4 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h4><table><thead><tr><th>问题</th><th>含义</th></tr></thead><tbody><tr><td>丢失更新（Lost Update）</td><td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td></tr><tr><td>脏读（Dirty Reads）</td><td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td></tr><tr><td>不可重复读（Non-Repeatable Reads）</td><td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td></tr><tr><td>幻读（Phantom Reads）</td><td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td></tr></tbody></table><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。</p><p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p><table><thead><tr><th>隔离级别</th><th>丢失更新</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read（默认）</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><blockquote><p>PS ： √ 代表可能出现 ， × 代表不会出现 。</p></blockquote><p>Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL8以前</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL8以后</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.transaction_isolation,@<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310102102301.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310102102301.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220310102102301"></p><h3 id="InnoDB-的行锁模式"><a href="#InnoDB-的行锁模式" class="headerlink" title="InnoDB 的行锁模式"></a>InnoDB 的行锁模式</h3><p>InnoDB 实现了以下两种类型的行锁。</p><ul><li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li><li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li></ul><p><code>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</code></p><p><code>对于普通SELECT语句，InnoDB不会加任何锁；</code></p><p>可以通过以下语句显示给记录集加共享锁或排他锁 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享锁（S）：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"></span><br><span class="line">排他锁（X) ：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> UPDATE    （悲观锁）</span><br></pre></td></tr></table></figure><blockquote><p><strong>悲观锁和乐观锁</strong></p><p>悲观锁：事务必须排队执行。数据锁住了，不允许并发。（行级锁：select后面添加for update）</p><p>乐观锁：支持并发，事务也不需要排队，只不过需要一个版本号。</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701184001613.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701184001613.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210701184001613"></p></blockquote><h3 id="行锁测试"><a href="#行锁测试" class="headerlink" title="行锁测试"></a>行锁测试</h3><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220310104005464">关闭自动提交功能</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">关闭自动提交功能</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104101547.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104101547.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220310104101547">可以正常的查询出全部的数据</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104101547.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104101547.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">可以正常的查询出全部的数据</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134407384.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134407384.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">查询id 为3的数据 ；</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134407384.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134407384.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">获取id为3的数据 ；</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134530170.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134530170.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311134530170">更新id为3的数据，但是不提交；</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134651586.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134651586.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311134651586">新id为3 的数据， 出于等待状态</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134713679.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134713679.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311134713679">通过commit， 提交事务</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134722373.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134722373.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311134722373">解除阻塞，更新正常进行</td></tr><tr><td>以上， 操作的都是同一行的数据，接下来，演示不同行的数据 ：</td><td></td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134822086.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134822086.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">新id为3数据，正常的获取到行锁 ， 执行更新 ；</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134845350.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311134845350.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">由于与Session-1 操作不是同一行，获取当前行锁，执行更新；</td></tr></tbody></table><blockquote><p>如果执行了更新语句，会对这一行数据加上排他锁（写锁），提交commit之后，会释放锁。另外一个线程update语句才可以执行解除阻塞状态。前提是两个线程操作同一行数据。</p></blockquote><h3 id="无索引时行锁升级为表锁"><a href="#无索引时行锁升级为表锁" class="headerlink" title="无索引时行锁升级为表锁"></a>无索引时行锁升级为表锁</h3><blockquote><p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p></blockquote><p>查看当前表的索引 ： show index from test_innodb_lock\G;<em><strong>（加上 \G 表示将查询结果进行按列打印，可以使每个字段打印到单独的行）</strong></em></p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311135321152.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311135321152.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311135321152"></p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220310104005464">关闭自动提交功能</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">关闭自动提交功能</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140314838.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140314838.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311140314838"> 执行更新语句 ：</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140358574.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140358574.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311140358574">执行更新语句， 但处于阻塞状态：</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140435841.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140435841.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311140435841">提交事务：</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140422475.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311140422475.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311140422475">解除阻塞，执行更新成功 ：</td></tr></tbody></table><blockquote><p>由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；(字符串类型，在SQL语句使用的时候没有加单引号，导致索引失效，查询没有走索引，进行全表扫描是，索引失效，行锁就升级为表锁)</p></blockquote><h3 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h3><blockquote><p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</p></blockquote><p>示例 ：</p><table><thead><tr><th>Session-1</th><th>Session-2</th></tr></thead><tbody><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220310104005464">关闭自动提交功能</td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220310104005464.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">关闭自动提交功能</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143815755.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143815755.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311143815755">根据id范围更新数据</td><td></td></tr><tr><td></td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143843041.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143843041.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311143843041">插入id为2的记录， 出于阻塞状态</td></tr><tr><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143911675.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143911675.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311143911675">提交事务</td><td>由于表数据中不存在id=2的数据，但是id&lt;4的行被加了排他锁，此时，这行数据就被加了间隙锁。无法插入</td></tr><tr><td></td><td><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143934727.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311143934727.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311143934727">解除阻塞 ， 执行插入操作 ：</td></tr></tbody></table><blockquote><p>怎样避免间隙锁呢？</p><p>在更新的时候，或者对数据行进行加锁的时候，尽量去缩小条件，使得间隙数据尽量的少，最大程度避免间隙锁的存在。</p></blockquote><h3 id="InnoDB-行锁争用情况"><a href="#InnoDB-行锁争用情况" class="headerlink" title="InnoDB 行锁争用情况"></a>InnoDB 行锁争用情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span>  status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311144126277.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220311144126277.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220311144126277"></p><p><strong>Innodb_row_lock_current_waits</strong>: 当前正在等待锁定的数量</p><p><strong>Innodb_row_lock_time</strong>: 从系统启动到现在锁定总时间长度</p><p><strong>Innodb_row_lock_time_avg</strong>:每次等待所花平均时长</p><p><strong>Innodb_row_lock_time_max</strong>:从系统启动到现在等待最长的一次所花的时间</p><p><strong>Innodb_row_lock_waits</strong>: 系统启动后到现在总共等待的次数</p><p>当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。</p></blockquote><blockquote><p>但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p></blockquote><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件，及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离（但是需要业务层面满足需求）</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 行锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁相关（一）</title>
      <link href="/2022/02/27/MySQL%E9%94%81%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/02/27/MySQL%E9%94%81%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><div class="story post-story"><p>从对数据操作的粒度分 ：</p><p>1） 表锁：操作时，会锁定整个表。</p><p>2） 行锁：操作时，会锁定当前操作行。</p><p>从对数据操作的类型分：</p><p>1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p></div><h2 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a>MySQL中的锁</h2><div class="story post-story"><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th align="left">页面锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td align="left">不支持</td></tr><tr><td>InnoDB</td><td>支持</td><td>支持(默认)</td><td align="left">不支持</td></tr><tr><td>MEMORY</td><td>支持</td><td>不支持</td><td align="left">不支持</td></tr><tr><td>BDB</td><td>支持</td><td>不支持</td><td align="left">支持</td></tr></tbody></table><p>MySQL这3种锁的特性可大致归纳如下 ：</p><table><thead><tr><th>锁类型</th><th>特点</th></tr></thead><tbody><tr><td>表级锁</td><td><code>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</code></td></tr><tr><td>行级锁</td><td><code>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</code></td></tr><tr><td>页面锁</td><td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td></tr></tbody></table><p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理系统。</p></div><h2 id="MyISAM的表锁"><a href="#MyISAM的表锁" class="headerlink" title="MyISAM的表锁"></a>MyISAM的表锁</h2><div class="story post-story"><p>MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。</p><h3 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h3><blockquote><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p></blockquote><p>显示加表锁语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加读锁 ： lock <span class="keyword">table</span> table_name read;</span><br><span class="line"></span><br><span class="line">加写锁 ： lock <span class="keyword">table</span> table_name write；</span><br></pre></td></tr></table></figure><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>Session-1 ：</p><p>1）获得tb_book 表的读锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock <span class="keyword">table</span> tb_book read;</span><br></pre></td></tr></table></figure><p>2） 执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309100813822.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309100813822.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309100813822">可以正常执行 ， 查询出数据。</p><p>Session-2：</p><p>3） 执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309100908848.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309100908848.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309100908848"></p><p>也可以正常执行，查询出数据。</p><p>Session-1：</p><p>4）查询未锁定的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101119113.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101119113.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309101119113"></p><p>Session-1查询未锁定的表失败。因为持有了一张tb_book的读锁，并未释放锁。</p><p>Session-2：</p><p>5）查询未锁定的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101105517.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101105517.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309101105517"></p><p>可以正常查询出未锁定的表；</p><p>Session-1 ：</p><p>6） 执行插入操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101227948.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101227948.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309101227948"></p><p>执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。只能读</p><p>Session-2 ：</p><p>7） 执行插入操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101338314.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101338314.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309101338314"></p><p>此时会处于等待状态，当在Session-1中释放锁指令 unlock tables 后 ， Session-2中的 inesrt 语句 ， 立即执行 ；</p><blockquote><p>如果对某一张表加了读锁，不会阻塞其它线程的读操作，但是会阻塞其它线程的写操作。</p></blockquote><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101524172.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309101524172.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309101524172"></p><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>Session-1 :</p><p>1）获得tb_book 表的写锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock <span class="keyword">table</span> tb_book write ;</span><br></pre></td></tr></table></figure><p>2）执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102636048.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102636048.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309102636048"></p><p>查询操作执行成功；加了写锁可以读。</p><p>3）执行更新操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_book <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;java编程思想（第二版）&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102712715.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102712715.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309102712715"></p><p>更新操作执行成功 ；（加了写锁当然可以写）</p><p>Session-2 :</p><p>4）执行查询操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book ;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102905513.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102905513.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309102905513"></p><p>当在Session-1中释放锁指令 unlock tables 后 ， Session-2中的 select 语句 ， 立即执行 ；（因为Session-1线程加的是写锁，写锁是排他锁，会阻断其他线程的读和写操作）</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102937221.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309102937221.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309102937221"></p></div><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><div class="story post-story"><p>锁模式的相互兼容性如表中所示：</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1553905621992.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1553905621992.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1553905621992"></p><p>由上表可见：</p><p> 1） <code>对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</code></p><p> 2） <code>对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</code></p><p> <code>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</code></p><blockquote><p>此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p></blockquote></div><h2 id="查看锁的争用情况"><a href="#查看锁的争用情况" class="headerlink" title="查看锁的争用情况"></a>查看锁的争用情况</h2><div class="story post-story"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables；</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309112041868.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309112041868.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309112041868"></p><p><code>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</code></p><p><code>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Table_locks%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309112122232.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220309112122232.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220309112122232"></p><p><code>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</code></p><p><code>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</code></p></div>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 表锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引的失效场景</title>
      <link href="/2022/02/25/MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/"/>
      <url>/2022/02/25/MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>索引设置</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104054069.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104054069.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301104054069"></p></blockquote><h2 id="1-最左前缀法则"><a href="#1-最左前缀法则" class="headerlink" title="1. 最左前缀法则"></a>1. 最左前缀法则</h2><div class="story post-story"><blockquote><p>最左前缀法则指的是查询从索引的最左前列开始，并且不跳过索引中的列。</p></blockquote><ul><li>匹配最左前缀法则，where条件中的顺序不影响使用索引，MySQL优化器会自动选择</li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104006580.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104006580.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301104006580"></p><ul><li>违反最左前缀法则，此时不走索引</li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104321534.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104321534.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301104321534"></p><ul><li>符合最左索引，但中间有跳跃，此时只会走最左边的部分索引，可以看到key_len（即使用的索引长度）是比第一张图中的key_len小的</li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104536762.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301104536762.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301104536762"></p></div><h2 id="2-范围查询右边的列"><a href="#2-范围查询右边的列" class="headerlink" title="2. 范围查询右边的列"></a>2. 范围查询右边的列</h2><div class="story post-story"><ul><li>都走索引时，key_len字段为456</li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110423472.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110423472.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301110423472"></p><ul><li>第二个条件使用范围搜索时，此时key_len是304，与只使用两个字段查询的key_len相同，说明后面的data_id字段没有走索引</li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110512163.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110512163.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301110512163"></p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110606981.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110606981.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301110606981"></p></div><h2 id="3-在索引字段上进行运算操作"><a href="#3-在索引字段上进行运算操作" class="headerlink" title="3.在索引字段上进行运算操作"></a>3.在索引字段上进行运算操作</h2><div class="story post-story"><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110951494.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301110951494.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301110951494"></p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301111000293.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301111000293.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301111000293"></p></div><h2 id="4-字段类型隐式转换"><a href="#4-字段类型隐式转换" class="headerlink" title="4.字段类型隐式转换"></a>4.字段类型隐式转换</h2><div class="story post-story"><blockquote><p>由于corpid字段是varchar类型，当where条件中不加引号时，mysql会进行隐式转换，此时索引会失效</p></blockquote><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301111054075.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301111054075.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301111054075"></p></div><h2 id="5-用or分割的字段条件，其中有一个字段未建立索引"><a href="#5-用or分割的字段条件，其中有一个字段未建立索引" class="headerlink" title="5.用or分割的字段条件，其中有一个字段未建立索引"></a>5.用or分割的字段条件，其中有一个字段未建立索引</h2><div class="story post-story"><blockquote><p>corpid为索引字段，而del为非索引字段</p></blockquote><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112058830.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112058830.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301112058830"></p></div><h2 id="6-MySQL优化器判断索引查询更慢"><a href="#6-MySQL优化器判断索引查询更慢" class="headerlink" title="6. MySQL优化器判断索引查询更慢"></a>6. MySQL优化器判断索引查询更慢</h2><div class="story post-story"><blockquote><p>当表中数据较少，或者查询的条件占表中数据的极大部分时，此时索引效率可能不如全表扫描，MySQL会选择全表扫描</p></blockquote><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112911831.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112911831.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301112911831"></p></div><h2 id="7-以-开头的模糊查询"><a href="#7-以-开头的模糊查询" class="headerlink" title="7.以%开头的模糊查询"></a>7.以%开头的模糊查询</h2><div class="story post-story"><blockquote><p>如果只是尾部的模糊查询是不会失效的</p><p>下图中使用强制索引是为了演示，因为表中数据较少，mysql判断索引速度不如全表扫描所以默认走了全表扫描</p></blockquote><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112413109.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112413109.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301112413109"></p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112452546.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112452546.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301112452546"></p><p>可以使用覆盖索引来解决该问题，即查询的列可以在索引中找到</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112637100.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20220301112637100.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20220301112637100"></p></div>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引失效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的触发器</title>
      <link href="/2022/02/24/MySQL%E4%B8%AD%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2022/02/24/MySQL%E4%B8%AD%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><div class="story post-story"><blockquote><p>触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端<strong>确保数据的完整性</strong> , <strong>日志记录</strong> , <strong>数据校验</strong>等操作 。</p></blockquote><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。（Oracle既有行级触发器，又有语句级触发器）</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD的使用</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table></div><h2 id="2-创建触发器"><a href="#2-创建触发器" class="headerlink" title="2. 创建触发器"></a>2. 创建触发器</h2><div class="story post-story"><h3 id="2-1-语法结构"><a href="#2-1-语法结构" class="headerlink" title="2.1 语法结构 :"></a>2.1 语法结构 :</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name trigger_time trigger_event <span class="keyword">ON</span> tb_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> trigger_stmt</span><br></pre></td></tr></table></figure><p>tb_name ：需要建立触发器的表名(只能是永久表，不能对临时表创建触发器)</p><p>trigger_name ：触发器名称，自行指定</p><p>trigger_time：触发时机，取值BEFORE、AFTER</p><p>trigger_event ：触发事件，INSERT、UPDATE、DELETE</p><p>trigger_stmt ： 触发程序体，可以是一条SQL语句或是BEGIN和END包含的多条语句</p><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><h4 id="2-2-1-需求"><a href="#2-2-1-需求" class="headerlink" title="2.2.1 需求"></a>2.2.1 需求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-首先创建一张日志表"><a href="#2-2-2-首先创建一张日志表" class="headerlink" title="2.2.2 首先创建一张日志表 :"></a>2.2.2 首先创建一张日志表 :</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_logs(</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">  operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作类型, insert/update/delete&#x27;</span>,</span><br><span class="line">  operate_time datetime <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;操作表的ID&#x27;</span>,</span><br><span class="line">  operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line">  <span class="keyword">primary</span> key(`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-创建-insert-型触发器，完成插入数据时的日志记录"><a href="#2-2-3-创建-insert-型触发器，完成插入数据时的日志记录" class="headerlink" title="2.2.3 创建 insert 型触发器，完成插入数据时的日志记录 :"></a>2.2.3 创建 insert 型触发器，完成插入数据时的日志记录 :</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_insert_trigger</span><br><span class="line">after <span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;插入后(id:&#x27;</span>,new.id,<span class="string">&#x27;, name:&#x27;</span>,new.name,<span class="string">&#x27;, age:&#x27;</span>,new.age,<span class="string">&#x27;, salary:&#x27;</span>,new.salary,<span class="string">&#x27;)&#x27;</span>));</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-创建-update-型触发器，完成更新数据时的日志记录"><a href="#2-2-4-创建-update-型触发器，完成更新数据时的日志记录" class="headerlink" title="2.2.4 创建 update 型触发器，完成更新数据时的日志记录 :"></a>2.2.4 创建 update 型触发器，完成更新数据时的日志记录 :</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_update_trigger</span><br><span class="line">after update </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;修改前(id:&#x27;</span>,old.id,<span class="string">&#x27;, name:&#x27;</span>,old.name,<span class="string">&#x27;, age:&#x27;</span>,old.age,<span class="string">&#x27;, salary:&#x27;</span>,old.salary,<span class="string">&#x27;) , 修改后(id&#x27;</span>,new.id, <span class="string">&#x27;name:&#x27;</span>,new.name,<span class="string">&#x27;, age:&#x27;</span>,new.age,<span class="string">&#x27;, salary:&#x27;</span>,new.salary,<span class="string">&#x27;)&#x27;</span>));                                                                      </span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-创建delete-行的触发器-完成删除数据时的日志记录"><a href="#2-2-5-创建delete-行的触发器-完成删除数据时的日志记录" class="headerlink" title="2.2.5 创建delete 行的触发器 , 完成删除数据时的日志记录 :"></a>2.2.5 创建delete 行的触发器 , 完成删除数据时的日志记录 :</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (id,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="string">&#x27;删除前(id:&#x27;</span>,old.id,<span class="string">&#x27;, name:&#x27;</span>,old.name,<span class="string">&#x27;, age:&#x27;</span>,old.age,<span class="string">&#x27;, salary:&#x27;</span>,old.salary,<span class="string">&#x27;)&#x27;</span>));                                                                      </span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="2-2-6-测试："><a href="#2-2-6-测试：" class="headerlink" title="2.2.6 测试："></a>2.2.6 测试：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;光明左使&#x27;</span>,<span class="number">30</span>,<span class="number">3500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,age,salary) <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;光明右使&#x27;</span>,<span class="number">33</span>,<span class="number">3200</span>);</span><br><span class="line"></span><br><span class="line">update emp <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">39</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></div><h2 id="3-删除触发器"><a href="#3-删除触发器" class="headerlink" title="3. 删除触发器"></a>3. 删除触发器</h2><div class="story post-story"><p>语法结构 :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name</span><br></pre></td></tr></table></figure><p>如果没有指定 schema_name，默认为当前数据库 。</p><h3 id="4-查看触发器"><a href="#4-查看触发器" class="headerlink" title="4. 查看触发器"></a>4. 查看触发器</h3><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p><p>语法结构 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers ;</span><br></pre></td></tr></table></figure></div><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><div class="story post-story"><ul><li><p>优点是可以在数据库层面保证数据的完整性，并且可以少写业务逻辑代码，使用方便。例如记录日志的功能，可以节省极大量的逻辑代码</p></li><li><p>缺点也很明显，逻辑在数据库层面，应用层调试困难，出现问题难以定位</p></li><li><p>注意点</p><ul><li><p>如果BEFORE触发器执行失败，SQL无法正确执行。</p></li><li><p>SQL执行失败时，AFTER型触发器不会触发。</p></li><li><p>AFTER类型的触发器执行失败，SQL会回滚。</p></li></ul></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 触发器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引结构</title>
      <link href="/2022/02/22/MySQL%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"/>
      <url>/2022/02/22/MySQL%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><code>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的</code>。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p><ul><li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li><li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li><li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li><li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li></ul><p><strong>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</strong></p><table><thead><tr><th>索引</th><th>InnoDB引擎</th><th>MyISAM引擎</th><th>Memory引擎</th></tr></thead><tbody><tr><td>BTREE索引</td><td><code>支持</code></td><td><code>支持</code></td><td><code>支持</code></td></tr><tr><td>HASH 索引</td><td>不支持</td><td>不支持</td><td><code>支持</code></td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p><h3 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h3><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p><ul><li>树中每个节点最多包含m个孩子。</li><li>除根节点与叶子节点外，每个节点至少有[(m/2)]个孩子。</li><li>若根节点不是叶子节点，则至少有两个孩子。</li><li>所有的叶子节点都在同一层。</li><li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1</li></ul><p>以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p><p>演变过程如下：</p><p>1). 插入前4个字母 C N G A</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944126588.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944126588.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944126588"></p><p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944549825.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944549825.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944549825"></p><p>3). 插入E，K，Q不需要分裂</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944596893.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944596893.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944596893"></p><p>4). 插入M，中间元素M字母向上分裂到父节点G</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944652560.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944652560.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944652560"></p><p>5). 插入F，W，L，T不需要分裂</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944686928.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944686928.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944686928"></p><p>6). 插入Z，中间元素T向上分裂到父节点中</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944713486.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944713486.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944713486"></p><p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944749984.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944749984.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944749984"></p><p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944848294.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555944848294.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555944848294"></p><p>到此，该BTREE树就已经构建完成了， <code>BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</code></p><h3 id="B-TREE-结构"><a href="#B-TREE-结构" class="headerlink" title="B+TREE 结构"></a>B+TREE 结构</h3><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p><blockquote><p>1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p><p>2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p><p>3). 所有的非叶子节点都可以看作是key的索引部分。</p></blockquote><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/00001.jpg" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/00001.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555906287178"></p><p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p><h4 id="MySQL中的B-Tree"><a href="#MySQL中的B-Tree" class="headerlink" title="MySQL中的B+Tree"></a>MySQL中的B+Tree</h4><p><code>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</code></p><p>MySQL中的 B+Tree 索引结构示意图:</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555906287178.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/1555906287178.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="1555906287178"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8、ElasticSearch索引Mapping映射关系</title>
      <link href="/2021/10/28/8%E3%80%81ElasticSearch%E7%B4%A2%E5%BC%95Mapping%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2021/10/28/8%E3%80%81ElasticSearch%E7%B4%A2%E5%BC%95Mapping%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ElasticSearch中的映射关系类似于关系型数据库中的表结构，用于说明该字段的类型及约束条件</p></blockquote><h2 id="创建一个新的索引"><a href="#创建一个新的索引" class="headerlink" title="创建一个新的索引"></a>创建一个新的索引</h2><div class="story post-story"><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT user</span><br></pre></td></tr></table></figure></div><h2 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h2><div class="story post-story"><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT user/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;name&quot;:&#123;</span><br><span class="line">    &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">    &quot;index&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;sex&quot;:&#123;</span><br><span class="line">    &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">    &quot;index&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tel&quot;:&#123;</span><br><span class="line">    &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">    &quot;index&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028101350171.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028101350171.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211028101350171"></p></div><h2 id="查询映射"><a href="#查询映射" class="headerlink" title="查询映射"></a>查询映射</h2><div class="story post-story"><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET user/_mapping</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028101648202.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028101648202.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211028101648202"></p></div><h2 id="映射作用"><a href="#映射作用" class="headerlink" title="映射作用"></a>映射作用</h2><div class="story post-story"><ul><li>先插入一条数据</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT user/_create/1001</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;小米&quot;,</span><br><span class="line">&quot;sex&quot;:&quot;男的&quot;,</span><br><span class="line">&quot;tel&quot;:&quot;1111&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询name中含有“小”的数据</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET user/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;name&quot;:&quot;小&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102103591.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102103591.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211028102103591"></p><ul><li>查询sex含有”男“的数据</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET user/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;sex&quot;:&quot;男&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102210981.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102210981.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211028102210981"></p><p>可以看到没有返回数据，原因是sex这个字段指定了类型为keyword，而keyword类型的字段不会被分词，因此需要完全匹配上才可以查询出数据</p><ul><li>查询sex含有”男的“的数据</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET user/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;sex&quot;:&quot;男的&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102411955.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102411955.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211028102411955"></p><ul><li>查询电话</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET user/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;tel&quot;:&quot;11&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102518193.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211028102518193.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211028102518193"></p><p>此时会报错，原因是创建映射时，指定了index为false，所以无法通过这个字段查询数据</p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7、ElasticSearch文档的查询(3)</title>
      <link href="/2021/10/27/7%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E6%9F%A5%E8%AF%A2(3)/"/>
      <url>/2021/10/27/7%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E6%9F%A5%E8%AF%A2(3)/</url>
      
        <content type="html"><![CDATA[<h2 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h2><div class="story post-story"><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match_phrase&quot;:&#123;</span><br><span class="line">&quot;category&quot; : &quot;为&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">  &quot;highlight&quot;:&#123;</span><br><span class="line">    &quot;fields&quot;:&#123;</span><br><span class="line">      &quot;category&quot;:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027170038855.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027170038855.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027170038855"></p></div><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><div class="story post-story"><p>聚合查询类似关系型数据库中的 group by，当然还有很多其他的聚合，例如取最大值max、平均值avg等等。</p><ul><li>按price字段进行分组：</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">&quot;price_group&quot;:&#123;</span><br><span class="line">&quot;terms&quot;:&#123;</span><br><span class="line">&quot;field&quot;:&quot;price&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027210556871.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027210556871.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027210556871"></p><p>上述的返回结果会携带原始数据，如果不想携带可以新增一个size的字段</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">&quot;price_group&quot;:&#123;</span><br><span class="line">&quot;terms&quot;:&#123;</span><br><span class="line">&quot;field&quot;:&quot;price&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;size&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027210746054.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027210746054.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027210746054"></p><ul><li>对所有手机价格求平均值</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;aggs&quot;:&#123;</span><br><span class="line">&quot;price_avg&quot;:&#123;</span><br><span class="line">&quot;avg&quot;:&#123;</span><br><span class="line">&quot;field&quot;:&quot;price&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">  &quot;size&quot;:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027211110652.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027211110652.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027211110652"></p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6、ElasticSearch文档的查询(2)</title>
      <link href="/2021/10/27/6%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E6%9F%A5%E8%AF%A2(2)/"/>
      <url>/2021/10/27/6%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E6%9F%A5%E8%AF%A2(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><div class="story post-story"><ul><li>假设想找出小米牌子，价格为3999元的。（must相当于数据库的&amp;&amp;）</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;must&quot;:[&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;category&quot;:&quot;小米&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;price&quot;:3999.00</span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027161613978.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027161613978.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027161613978"></p><ul><li>假设想找出小米和华为的牌子。（should相当于数据库的||）</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;bool&quot;:&#123;</span><br><span class="line">&quot;should&quot;:[&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;category&quot;:&quot;小米&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;category&quot;:&quot;华为&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027164254939.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027164254939.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027164254939"></p><ul><li>假设想找出小米和华为的牌子，价格大于4000元的手机。</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;category&quot;: &quot;小米&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;category&quot;: &quot;华为&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;filter&quot;: &#123;</span><br><span class="line">      &quot;range&quot;: &#123;</span><br><span class="line">          &quot;price&quot;: &#123;</span><br><span class="line">            &quot;gt&quot;: 4000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027164444808.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027164444808.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027164444808"></p></div><h2 id="完全匹配查询"><a href="#完全匹配查询" class="headerlink" title="完全匹配查询"></a>完全匹配查询</h2><div class="story post-story"><p>即需要完全包含搜索条件的查询，查询条件不做分词处理</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;category&quot;: &quot;小为&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027165009701.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027165009701.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027165009701"></p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5、ElasticSearch文档的查询(1)</title>
      <link href="/2021/10/27/5%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E6%9F%A5%E8%AF%A2(1)/"/>
      <url>/2021/10/27/5%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E6%9F%A5%E8%AF%A2(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="主键查询"><a href="#主键查询" class="headerlink" title="主键查询"></a>主键查询</h2><div class="story post-story"><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_doc/1</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027140851488.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027140851488.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027140851488"></p></div><h2 id="全查询"><a href="#全查询" class="headerlink" title="全查询"></a>全查询</h2><div class="story post-story"><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027140943179.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027140943179.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027140943179"></p></div><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><div class="story post-story"><h3 id="通过链接上拼接参数的方式"><a href="#通过链接上拼接参数的方式" class="headerlink" title="通过链接上拼接参数的方式"></a>通过链接上拼接参数的方式</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search?q=category:华为</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027152139551.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027152139551.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027152139551"></p><p><code>PS:不建议将参数拼接在链接上，可能会有乱码问题</code></p><h3 id="通过请求体"><a href="#通过请求体" class="headerlink" title="通过请求体"></a>通过请求体</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match&quot;:&#123;</span><br><span class="line">&quot;category&quot;:&quot;华为&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027152616844.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027152616844.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027152616844"></p><h3 id="通过请求体查询所有"><a href="#通过请求体查询所有" class="headerlink" title="通过请求体查询所有"></a>通过请求体查询所有</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027152938043.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027152938043.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027152938043"></p><h3 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;_source&quot;:[&quot;title&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027154525570.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027154525570.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027154525570"></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;from&quot;:0,</span><br><span class="line">&quot;size&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027154739085.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027154739085.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027154739085"></p><h3 id="查询排序"><a href="#查询排序" class="headerlink" title="查询排序"></a>查询排序</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;sort&quot;:&#123;</span><br><span class="line">&quot;price&quot;:&#123;</span><br><span class="line">&quot;order&quot;:&quot;desc&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027155008884.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027155008884.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027155008884"></p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4、ElasticSearch文档的修改</title>
      <link href="/2021/10/27/4%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
      <url>/2021/10/27/4%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="完全覆盖修改"><a href="#完全覆盖修改" class="headerlink" title="完全覆盖修改"></a>完全覆盖修改</h2><div class="story post-story"><p>完全覆盖操作是幂等操作，因此可以使用PUT方法</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT shopping/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;华为手机&quot;,</span><br><span class="line">    &quot;category&quot;:&quot;华为&quot;,</span><br><span class="line">    &quot;images&quot;:&quot;http://www.gulixueyuan.com/hw.jpg&quot;,</span><br><span class="line">    &quot;price&quot;:1999.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027141420028.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027141420028.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027141420028"></p><p>此时再获取一下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET shopping/_doc/1</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027141504405.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027141504405.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027141504405"></p><p>可以看到整个数据体被完全覆盖了</p></div><h2 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h2><div class="story post-story"><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST shopping/_upodate/1</span><br><span class="line">&#123;</span><br><span class="line">&quot;doc&quot;: &#123;</span><br><span class="line">&quot;title&quot;:&quot;OPPO手机&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027143257707.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027143257707.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027143257707"></p><p>此时再获取一遍</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027143420473.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027143420473.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027143420473"></p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3、ElasticSearch文档的创建及删除</title>
      <link href="/2021/10/27/3%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2021/10/27/3%E3%80%81ElasticSearch%E6%96%87%E6%A1%A3%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><div class="story post-story"><p>创建文档需要使用POST请求，如果用PUT请求则会报错，原因是PUT请求应当为幂等性操作，而不指定id直接创建文档时，会不断生成新的文档，该操作不为幂等操作，因此无法使用PUT请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT shopping/_doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;小米手机&quot;,</span><br><span class="line">    &quot;category&quot;:&quot;小米&quot;,</span><br><span class="line">    &quot;images&quot;:&quot;http://www.gulixueyuan.com/xm.jpg&quot;,</span><br><span class="line">    &quot;price&quot;:3999.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027112442078.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027112442078.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027112442078"></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST shopping/_doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;小米手机&quot;,</span><br><span class="line">    &quot;category&quot;:&quot;小米&quot;,</span><br><span class="line">    &quot;images&quot;:&quot;http://www.gulixueyuan.com/xm.jpg&quot;,</span><br><span class="line">    &quot;price&quot;:3999.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027112509288.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027112509288.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027112509288"></p><p><code>PS:创建文档时，如果指定索引不存在，则会自动创建该索引</code></p><p><code>_id</code>为ElasticSearch自动为该文档生成的id，如果想要自己指定id，则需要在url后面拼接上id</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST shopping/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;小米手机&quot;,</span><br><span class="line">    &quot;category&quot;:&quot;小米&quot;,</span><br><span class="line">    &quot;images&quot;:&quot;http://www.gulixueyuan.com/xm.jpg&quot;,</span><br><span class="line">    &quot;price&quot;:3999.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027112840556.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027112840556.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027112840556"></p><p>指定id后，操作就是幂等操作了，因此理论上可以换成PUT方式请求，</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT shopping/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;小米手机&quot;,</span><br><span class="line">    &quot;category&quot;:&quot;小米&quot;,</span><br><span class="line">    &quot;images&quot;:&quot;http://www.gulixueyuan.com/xm.jpg&quot;,</span><br><span class="line">    &quot;price&quot;:3999.00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027134733636.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027134733636.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027134733636"></p></div><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><div class="story post-story"><p>同理，只要将请求方式改为DELETE即可</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE shopping/_doc/1</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027135132674.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027135132674.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027135132674"></p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、ElasticSearch索引的创建查询及删除</title>
      <link href="/2021/10/27/2%E3%80%81ElasticSearch%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%88%A0%E9%99%A4/"/>
      <url>/2021/10/27/2%E3%80%81ElasticSearch%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>后续操作均在Kibana的Dev Tools中完成</p></blockquote><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><div class="story post-story"><p>创建使用PUT的请求方式</p><p>先创建一个名为shopping的索引</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT shopping</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027103327907.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027103327907.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027103327907"></p><p>此时再次调用则会报错</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027103455940.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027103455940.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027103455940"></p></div><h2 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h2><div class="story post-story"><ul><li><p>查询指定索引</p><p>将PUT改为GET即可</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET shopping</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027103955039.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027103955039.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027103955039"></p><ul><li><p>查询所有的索引</p><p>加上<code>?v</code>后会展示字段头信息</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/indices?v</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027104156013.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027104156013.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027104156013"></p></div><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><div class="story post-story"><p>与查询指定索引的逻辑一致，将请求方式改为DELETE即可</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE shopping</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027104517785.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027104517785.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027104517785"></p><p>此时再查询则会返回404</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET shopping</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027104611499.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20211027104611499.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20211027104611499"></p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、Docker安装ElasticSearch和Kibana</title>
      <link href="/2021/10/26/1%E3%80%81Docker%E5%AE%89%E8%A3%85ElasticSearch%E5%92%8CKibana/"/>
      <url>/2021/10/26/1%E3%80%81Docker%E5%AE%89%E8%A3%85ElasticSearch%E5%92%8CKibana/</url>
      
        <content type="html"><![CDATA[<h2 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><div class="story post-story"><p>先拉下es的镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.12.0</span><br></pre></td></tr></table></figure><p>镜像拉取完毕后新建容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -d elasticsearch:7.12.0</span><br></pre></td></tr></table></figure><p>等es启动完成后，可以在命令行输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9200</span><br></pre></td></tr></table></figure><p>或者在浏览器中打开<a href="http://">http://127.0.0.1:9200</a>这个网址，如果能看到以下信息则说明我们的es是已经安装好了的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;e0c0b0ff715b&quot;,</span><br><span class="line">    &quot;cluster_name&quot;: &quot;elasticsearch&quot;,</span><br><span class="line">    &quot;cluster_uuid&quot;: &quot;c42jGCPrRHiGTix4pUl9EQ&quot;,</span><br><span class="line">    &quot;version&quot;: &#123;</span><br><span class="line">        &quot;number&quot;: &quot;7.12.0&quot;,</span><br><span class="line">        &quot;build_flavor&quot;: &quot;default&quot;,</span><br><span class="line">        &quot;build_type&quot;: &quot;docker&quot;,</span><br><span class="line">        &quot;build_hash&quot;: &quot;78722783c38caa25a70982b5b042074cde5d3b3a&quot;,</span><br><span class="line">        &quot;build_date&quot;: &quot;2021-03-18T06:17:15.410153305Z&quot;,</span><br><span class="line">        &quot;build_snapshot&quot;: false,</span><br><span class="line">        &quot;lucene_version&quot;: &quot;8.8.0&quot;,</span><br><span class="line">        &quot;minimum_wire_compatibility_version&quot;: &quot;6.8.0&quot;,</span><br><span class="line">        &quot;minimum_index_compatibility_version&quot;: &quot;6.0.0-beta1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tagline&quot;: &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h4><p>es自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入容器，然后进入plugins目录中下载分词器，下载完成后重启es即可。具体步骤如下:</p><p><strong>注意：</strong>elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启的时候会失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line">cd /usr/share/elasticsearch/plugins/</span><br><span class="line">elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.0/elasticsearch-analysis-ik-7.12.0.zip</span><br></pre></td></tr></table></figure></div><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><div class="story post-story"><p>同样适用docker安装kibana命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.12.0</span><br></pre></td></tr></table></figure><p>安装完成以后需要启动kibana容器，需要使用<code>--link</code>连接到elasticsearch容器，<code>--link</code>命令的格式为name:alias，即需要绑定的容器名称以及赋予的别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana --link=elasticsearch:es  -p 5601:5601 -d kibana:7.12.0</span><br></pre></td></tr></table></figure><p>启动后需要修改kibana的配置文件，将连接es的地址修改为创建容器时填入的别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line">cd /usr/share/kibana/config/</span><br><span class="line">vi kibana.yml</span><br></pre></td></tr></table></figure><p>将<code>elasticsearch.hosts</code>项修改为 <code>[ &quot;http://es:9200&quot; ]</code></p><p>重启kibana后在浏览器中输入kibana的地址即可打开kibana的页面了</p></div>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-limit数据丢失问题</title>
      <link href="/2021/10/26/Mysql-limit%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/26/Mysql-limit%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在项目中遇到一个很奇怪的bug，前端调接口分页返回数据时，有两条数据在第一页的最后返回了，然后又在第二页的头返回了，本以为是程序的问题，排查了半天最后发现是Mysql的问题。</p></blockquote><h2 id="Mysql表数据"><a href="#Mysql表数据" class="headerlink" title="Mysql表数据"></a>Mysql表数据</h2><div class="story post-story"><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091251361.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091251361.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210701091251361"></p></div><h2 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h2><div class="story post-story"><h4 id="先尝试查询前二十条数据"><a href="#先尝试查询前二十条数据" class="headerlink" title="先尝试查询前二十条数据"></a>先尝试查询前二十条数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_customer_open_sea WHERE corpid = &#x27;1&#x27; AND del = 0 LIMIT 0,20;</span><br></pre></td></tr></table></figure><p>返回结果</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091352328.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091352328.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210701091352328"></p><p>可以看到id为2和3的数据丢失了，同时返回了id为21和22的数据，此时再查询第二页的数据时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_customer_open_sea WHERE corpid = &#x27;1&#x27; AND del = 0 LIMIT 20,20;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091429496.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091429496.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210701091429496"></p><p>再次返回了id为21和22的数据，这就离谱了，丢了两条数据，难道是没满足where条件吗？于是我去掉了limit试了试</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091532394.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091532394.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210701091532394"></p><p>id为2和3的数据出现了….而和刚才那条SQL的区别只是去掉了limit，难道limit还会影响查询结果？？？然后我又在limit的基础上加上了order by</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210630224930575.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210630224930575.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210630224930575"></p><p>此时返回的数据中包含了2和3，说明是满足条件的，只是返回的顺序不对可能2和3的数据排在了二十条以后，但是为什么第二页也不包含这两条数据呢</p><p>于是我explain了一下这两条sql，发现这两条sql唯一的区别就是第一条走了联合索引，第二条没走联合索引，于是我又尝试了让第二条sql走索引</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091626683.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210701091626683.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210701091626683"></p><p>消失的数据又出现了，果然是索引的问题(不用limit 20,9是因为表中一共就29条数据，这样的话就是全表扫描不会走索引了)</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>当使用limit不使用order by时，且查询条件走了普通索引，就可能会按普通索引的顺序返回数据，所以用了limit就尽量加上order by</p></div>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发-CAS-乐观锁-解析</title>
      <link href="/2021/05/26/Java%E5%B9%B6%E5%8F%91-CAS-%E4%B9%90%E8%A7%82%E9%94%81-%E8%A7%A3%E6%9E%90/"/>
      <url>/2021/05/26/Java%E5%B9%B6%E5%8F%91-CAS-%E4%B9%90%E8%A7%82%E9%94%81-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本文讲解CAS机制，主要是因为最近准备面试题，发现这个问题在面试中出现的频率非常的高，因此把自己学习过程中的一些理解记录下来。</p></blockquote><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul><li><p>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</p></li><li><p>CAS操作的就是乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p></li></ul><h3 id="模拟线程安全问题"><a href="#模拟线程安全问题" class="headerlink" title="模拟线程安全问题"></a>模拟线程安全问题</h3><p>先看下面的代码，执行结果不言而喻，最终的结果一定是小于预期的1000</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并发时线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Suave</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 2021/3/5 1:50 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> threadSize = <span class="number">100</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        request();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.printf(<span class="string">&quot;消耗时长: %d, 结果: %d&quot;</span>, endTime - startTime, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210305154019790.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210305154019790.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="&quot;执行结果&quot;"></p><p>这段代码线程不安全的具体原因是 <strong>count++</strong> 并不是一个原子性的操作，count++实际会经过三个步骤</p><ul><li>获取 count 的值，先记为 A    A = count</li><li>将 A 的值加一，得到B    B = A+1</li><li>将 B 的值赋给 count    count = B</li></ul><p>在多线程的情况下，可能会有多个线程同时走到第一步，同时获取到了相同的A</p><p>此时新增后将值赋给B就会出现多个线程调用了这个方法结果count只加了一的情况</p><h3 id="线程安全问题解决"><a href="#线程安全问题解决" class="headerlink" title="线程安全问题解决"></a>线程安全问题解决</h3><ul><li>线程安全的问题可以通过加锁的方式解决，先来试试最常用也最方便的synchronized关键字，即假设每次都会有冲突，一次只允许一个线程进入的悲观锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在request方法上面加上synchronized关键字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    再来运行试一下</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210305155226372.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210305155226372.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="&quot;执行结果&quot;"></p><p>​    可以看到，执行结果和我们预期的一致，线程已经安全了。</p><p>​    但是，这个运行效率就很感人了………</p><ul><li>用CAS乐观锁解决</li></ul><p>增加一个CAS方法，同时更改request方法，每次赋值的时候去比较一下值是否发生了改变，改变了就重试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * CAS方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expectCount 期望值count</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newCount    需要给count赋的新值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectCount, <span class="keyword">int</span> newCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == expectCount) &#123;</span><br><span class="line">      count = newCount;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">      <span class="keyword">int</span> expectCount;</span><br><span class="line">      <span class="comment">// expectCount返回false时要再获取count的值并重新赋值</span></span><br><span class="line">      <span class="keyword">while</span> (!compareAndSwap(expectCount=count, expectCount + <span class="number">1</span>)) &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210305160816328.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210305160816328.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="&quot;执行结果&quot;"></p><p>可以看到，执行结果与我们预期的一致，性能也要强于synchronized悲观锁</p><p><em><strong>那么这段乐观锁的代码就一定不会出问题了吗？</strong></em></p><p>CPU执行某一段代码的时候，会先将数据读取到高速缓存中，极端情况下，当该线程将数据读取到高速缓存中时，其他线程更新了主存中的值，此时我们缓存中的值就不准确了</p><p>当我们以缓存中的值做CAS操作时，就会与预期值不一致了，因此，还要在 <strong>count</strong> 属性上加上 <em><strong>volatile</strong></em> 关键字，保证程序的可见性，每次获取该值时都去主存中获取</p><h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3><p>当然，CAS也是有缺点的</p><ol><li><p>CPU开销较大<br>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p></li><li><p>不能保证代码块的原子性<br>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 锁机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类-RandomAccess接口</title>
      <link href="/2021/04/26/Java%E9%9B%86%E5%90%88%E7%B1%BB-RandomAccess%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/04/26/Java%E9%9B%86%E5%90%88%E7%B1%BB-RandomAccess%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="发现RandomAccess接口"><a href="#发现RandomAccess接口" class="headerlink" title="发现RandomAccess接口"></a>发现RandomAccess接口</h2><div class="story post-story"><p>因为面试的时候问到了怎样使一个 <strong>ArrayList</strong> 变得线程安全</p><ol><li>使用老牌的Vetor</li><li>使用CopyOnWriteArrayList</li><li>使用Collections.syncronizedList()方法传入一个List，会返回一个线程安全的List</li></ol><p>答完后引申到Collections.syncronizedList()的实现原理，当时没看过具体实现并未回答上来。复盘时研究了下，发现首先会先判断传过来的List是否实现了RandomAccess接口<br><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20210302112045.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20210302112045.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div><h2 id="RandomAccess接口详解"><a href="#RandomAccess接口详解" class="headerlink" title="RandomAccess接口详解"></a>RandomAccess接口详解</h2><div class="story post-story"><p>点进Random接口发现该接口并没有任何属性和任何方法</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20210302112503.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20210302112503.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>于是查看jdk8官方文档</p><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20210302113604.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/20210302113604.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>官方文档写明了，RandomAccess接口主要是一个标记接口，用来注明这个List是否支持随机访问。</p><blockquote><p>ArrayList实现了Random接口而LinkedList并未实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>ArrayList底层是数组，占用一片连续的空间，可以通过计算偏移量来直接获取元素，即支持随机访问，此时使用for (int i=0, n=list.size(); i &lt; n; i++){}循环时的速度要快于iterator顺序循环访问</p><p>LinkedList底层是双向链表，遍历要按顺序一个元素节点一个元素节点查询下去，此时iterator速度要快于for (int i=0, n=list.size(); i &lt; n; i++){}</p></div><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><div class="story post-story"><ul><li>随机往数组和链表中插入100000个元素，并分别打印遍历时间</li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210302211040899.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210302211040899.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210302211040899"></p><ul><li>遍历结果</li></ul><p><img src="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210302211247553.png" class="lazyload" data-srcset="https://blog-pic-project.oss-cn-hangzhou.aliyuncs.com/img/image-20210302211247553.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210302211247553"></p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="story post-story"><p>可以看到ArrayList（即RandomAccess接口标识的类）使用普通for循环遍历速度较快</p><p>而LinkedList（即未被RandomAccess接口标识的类）使用迭代器遍历速度远快于普通for遍历</p><p>后续遍历时可以根据是否被RandomAccess接口标识选择更优的遍历方式</p></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的值传递和引用传递</title>
      <link href="/2020/07/26/Java%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/2020/07/26/Java%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java中的参数传递分为值传递和引用传递，基本类型是值传递，封装类是引用传递。</p></blockquote><h1 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        change(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码的输出结果是<code>num=0</code>。</p><p>当调用<code>change</code>方法时，jvm实际上是复制了一份参数传入方法中，无论这个复制后的参数怎么变，<code>main</code>方法中的<code>num</code>参数都是不会发生变化的。</p><p>从内存分配的角度来看，栈中是有两个变量的。一个是<code>main</code>方法中定义的<code>num</code>，另外一个是在传参时jvm复制的一份<code>num</code>副本，我们就叫它<code>temp</code>。不论<code>temp</code>值怎么改变，<code>num</code>是不会变的。</p><h1 id="引用传值"><a href="#引用传值" class="headerlink" title="引用传值"></a>引用传值</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeAge</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        student.setAge(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">18</span>);</span><br><span class="line">        changeAge(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;student.age=&quot;</span> + student.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码的输出结果是<code>student.age=20</code>。</p><p><code>main</code>方法<code>new Student</code>时，jvm在堆中分配了一块内存用于存放<code>Student</code>对象。并且在栈中存放一个<code>student</code>对象，值是指向堆中<code>Student</code>对象的地址。</p><p>把<code>student</code>变量传入<code>changeAge()</code>方法时，jvm复制了一份<code>student</code>变量。为了便于理解我们叫它<code>temp</code>，<code>temp</code>的值和<code>student</code>是一样的，都是指向堆中<code>Student</code>对象的地址。</p><p>也就是说两个指针都指向了堆中<code>Student</code>对象的地址，此时修改的也就是堆中的该对象，因此<code>main</code>中的<code>student</code>对象也发生了变化</p><h1 id="特殊的String"><a href="#特殊的String" class="headerlink" title="特殊的String"></a>特殊的String</h1><blockquote><p>按照上面的说法，String不是基本类型，按理来说应该是引用传递</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        change(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上上面输出的结果是<code>str = 123</code>。</p><p>jvm在实例化字符串时会使用字符串常量池，把<code>str</code>作为参数传入<code>change()</code>方法。jvm复制了一份<code>str</code>变量，为了便于理解我们叫它<code>temp</code>。这个时候<code>str</code>和<code>temp</code>都指向字符串常量池中的<code>&quot;123&quot;</code>。</p><p>后续给<code>temp</code>重新赋值为<code>&quot;456&quot;</code>，可以理解为在常量池中新建了<code>&quot;456&quot;</code>这个字符串，并将<code>temp</code>指向常量池中的<code>&quot;456&quot;</code>，此时<code>str</code>的指向是没有发生变化的，因此还是<code>&quot;123&quot;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
